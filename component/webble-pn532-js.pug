script.
  /* global define */
  ;(function (root, factory) { // amdWebGlobal
    if (!(typeof define === 'function' && define.amd)) return (root.Pn532 = factory(root._))
    define(['_'], _ => (root.Pn532 = factory(_)))
  }(typeof self !== 'undefined' ? self : this, _ => {
    const FRAME_ACK = new Uint8Array([0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00])
    const ERROR_CODE = _.fromPairs([
      ['01', 'Time Out, the target has not answered'],
      ['02', 'A CRC error has been detected by the CIU'],
      ['03', 'A Parity error has been detected by the CIU'],
      ['04', 'During an anti-collision/select operation (ISO/IEC14443-3 Type A and ISO/IEC18092 106 kbps passive mode), an erroneous Bit Count has been detected'],
      ['05', 'Framing error during Mifare operation'],
      ['06', 'An abnormal bit-collision has been detected during bit wise anti-collision at 106 kbps'],
      ['07', 'Communication buffer size insufficient'],
      ['09', 'RF Buffer overflow has been detected by the CIU (bit BufferOvfl of the register CIU_Error)'],
      ['0a', 'In active communication mode, the RF field has not been switched on in time by the counterpart (as defined in NFCIP-1 standard)'],
      ['0b', 'RF Protocol error (description of the CIU_Error register)'],
      ['0d', 'Temperature error: the internal temperature sensor has detected overheating, and therefore has automatically switched off the antenna drivers'],
      ['0e', 'Internal buffer overflow'],
      ['10', 'Invalid parameter (range, format, ...)'],
      ['12', 'DEP Protocol: The PN532 configured in target mode does not support the command received from the initiator (the command received is not one of the following: ATR_REQ, WUP_REQ, PSL_REQ, DEP_REQ, DSL_REQ, RLS_REQ)'],
      ['13', 'DEP Protocol, Mifare or ISO/IEC14443-4: The data format does not match to the specification. Depending on the RF protocol used, it can be: Bad length of RF received frame, Incorrect value of PCB or PFB, Invalid or unexpected RF received frame, NAD or DID incoherence.'],
      ['14', 'Mifare: Authentication error'],
      ['23', 'ISO/IEC14443-3: UID Check byte is wrong'],
      ['25', 'DEP Protocol: Invalid device state, the system is in a state which does not allow the operation'],
      ['26', 'Operation not allowed in this configuration (host controller interface)'],
      ['27', 'This command is not acceptable due to the current context of the PN532 (Initiator vs. Target, unknown target number, Target not in the good state, ...)'],
      ['29', 'The PN532 configured as target has been released by its initiator'],
      ['2a', 'PN532 and ISO/IEC14443-3B only: the ID of the card does not match, meaning that the expected card has been exchanged with another one.'],
      ['2b', 'PN532 and ISO/IEC14443-3B only: the card previously activated has disappeared.'],
      ['2c', 'Mismatch between the NFCID3 initiator and the NFCID3 target in DEP 212/424 kbps passive.'],
      ['2d', 'An over-current event has been detected'],
      ['2e', 'NAD missing in DEP frame'],
    ])
    const errToPlainObj = (() => {
      const ERROR_KEYS = [
        'address',
        'code',
        'data',
        'dest',
        'errno',
        'info',
        'message',
        'name',
        'path',
        'port',
        'reason',
        'response.data',
        'response.headers',
        'response.status',
        'stack',
        'status',
        'statusCode',
        'statusMessage',
        'syscall',
      ]
      return err => _.pick(err, ERROR_KEYS)
    })()
    class Pn532 {
      constructor () {
        this.ackHandlers = null
        this.charRecv = null
        this.charSend = null
        this.device = null
        this.resHandlers = null
        this.service = null
        this.uuidRecv = 0xffe1
        this.uuidSend = 0xffe2
        this.uuidServ = 0xffe0
        this.verbose = false
      }

      async diagnose ({ test = 0x00, data = null, timeout = 1000 }) {
        data = this.castUint8Array(data)
        const frame = this.frameCreateNormal(3 + _.get(data, 'byteLength', 0)) // include len of TFI
        frame.u8.set(new Uint8Array([0x00, test]), frame.data.byteOffset)
        if (data) frame.u8.set(data, frame.data.byteOffset + 2) // test input
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame, resTimeout: timeout })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
        return {
          status,
          ...(res.len <= 3 ? {} : {
            data: new DataView(res.buffer, res.data.byteOffset + 2, res.len - 3),
          }),
        }
      }

      async diagnosePing () {
        const res = await this.diagnose({ test: 0x00, data: this.u8FromUtf8('ping') })
        if (!res.data) throw new Error('no data in response')
        const actual = this.u8ToUtf8(res.data)
        if (actual !== 'ping') throw new Error('response data mismatch')
        return true
      }

      async diagnose06 () {
        return await this.diagnose({ test: 0x06 })
      }

      async getFirmwareVersion () {
        const frame = this.frameCreateNormal(2) // include len of TFI
        frame.data.setUint8(0, 0x02)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        return {
          ic: `PN5${this.dvGetHex(res.data, 1)}`,
          ver: res.data.getUint8(2),
          rev: res.data.getUint8(3),
          support: res.data.getUint8(4),
        }
      }

      async readRegisters (adrs = []) {
        if (!_.isArray(adrs) || !adrs.length) throw new Error('invalid adrs')
        const frame = this.frameCreateNormal(adrs.length * 2 + 2) // include len of TFI
        frame.data.setUint8(0, 0x06)
        for (let i = 0; i < adrs.length; i++) frame.data.setUint16(i * 2 + 1, adrs[i])
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        return _.zipObject(adrs, new Uint8Array(res.buffer, res.data.byteOffset + 1, res.len - 2))
      }

      async writeRegisters (regs) {
        if (_.isPlainObject(regs)) regs = _.toPairs(regs)
        if (!_.isArray(regs) || !regs.length) throw new Error('invalid regs')
        const frame = this.frameCreateNormal(regs.length * 3 + 2) // include len of TFI
        frame.data.setUint8(0, 0x08)
        for (let i = 0; i < regs.length; i++) {
          frame.data.setUint16(i * 3 + 1, _.parseInt(_.get(regs, `${i}.0`, 0)))
          frame.data.setUint8(i * 3 + 3, _.parseInt(_.get(regs, `${i}.1`, 0)))
        }
        this.frameGenerateDCS(frame)
        await this.frameExec({ frame })
      }

      async readGpio () {
        const frame = this.frameCreateNormal(2) // include len of TFI
        frame.data.setUint8(0, 0x0c)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        return _.fromPairs([
          ..._.times(6, i => [`p3${i}`, (res.data.getUint8(0) >> i) & 1]),
          ..._.times(2, i => [`p7${i + 1}`, (res.data.getUint8(1) >> (i + 1)) & 1]),
          ..._.times(2, i => [`i${i}`, (res.data.getUint8(2) >> i) & 1]),
        ])
      }

      async writeGpio (gpio = {}) {
        const frame = this.frameCreateNormal(4) // include len of TFI
        frame.data.setUint8(0, 0x0e)
        let p3 = 0x80 // VALIDATION BIT
        for (let i = 0; i < 6; i++) p3 |= gpio[`p3${i}`] ? (1 << i) : 0
        frame.data.setUint8(1, p3)
        frame.data.setUint8(2, 0) // P7
        this.frameGenerateDCS(frame)
        await this.frameExec({ frame })
      }

      async samConfiguration ({ mode = 1, timeout = 0x14, irq = 1 } = {}) {
        const frame = this.frameCreateNormal(5) // include len of TFI
        frame.u8.set(new Uint8Array([0x14, mode, timeout, irq]), frame.data.byteOffset)
        this.frameGenerateDCS(frame)
        await this.frameExec({ frame })
      }

      async rfConfiguration ({ item, data = null } = {}) {
        data = this.castUint8Array(data)
        const frame = this.frameCreateNormal(3 + _.get(data, 'byteLength', 0)) // include len of TFI
        frame.u8.set(new Uint8Array([0x32, item]), frame.data.byteOffset)
        if (data) frame.u8.set(data, frame.data.byteOffset + 2) // initiator data
        this.frameGenerateDCS(frame)
        return await this.frameExec({ frame })
      }

      async rfSetField ({ autoRfca = 1, rfOnOff = 0 } = {}) {
        return await this.rfConfiguration({
          item: 1,
          data: new Uint8Array([ (autoRfca ? 2 : 0) + (rfOnOff ? 1 : 0) ]),
        })
      }

      /**
       * timeouts[0]: defines the timeout between ATR_REQ and ATR_RES
       * timeouts[1]: defines the timeout value that the PN532 uses in the InCommunicateThru and InDataExchange
       * 0x00: no timeout, 0x01 = 100 μs, 0x02 = 200 μs, 0x03 = 400 μs, 0x04 = 800 μs, 0x05 = 1.6 ms, 0x06 = 3.2 ms, 0x07 = 6.4 ms, 0x08 = 12.8 ms, 0x09 = 25.6 ms, 0x0A = 51.2 ms, 0x0B = 102.4 ms, 0x0C = 204.8 ms, 0x0D = 409.6 ms, 0x0E = 819.2 ms, 0x0F = 1.64 sec, 0x10 = 3.28 sec
       */
      async rfSetTimeouts (timeouts = [0x0b, 0x0a]) {
        if (timeouts.length !== 2 || !_.inRange(timeouts[0], 0, 0x11) || !_.inRange(timeouts[1], 0, 0x11)) throw new Error('invalid timeouts')
        return await this.rfConfiguration({
          item: 2,
          data: new Uint8Array([0, ...timeouts]),
        })
      }

      async rfSetMaxRetries ({ atr = 0xff, psl = 0x01, passiveActivation = 0xff } = {}) {
        return await this.rfConfiguration({ item: 5, data: new Uint8Array([atr, psl, passiveActivation]) })
      }

      async inListPassiveTarget ({ maxTg = 1, brTy = 0, data = null, timeout = 3e4 } = {}) {
        data = this.castUint8Array(data)
        const frame = this.frameCreateNormal(4 + _.get(data, 'byteLength', 0)) // include len of TFI
        frame.u8.set(new Uint8Array([0x4a, maxTg, brTy]), frame.data.byteOffset)
        if (data) frame.u8.set(data, frame.data.byteOffset + 3) // initiator data
        this.frameGenerateDCS(frame)
        return await this.frameExec({ frame, resTimeout: timeout })
      }

      async hf14aListPassiveTarget ({ maxTg = 1, uid = null, timeout } = {}) {
        if (uid) {
          uid = this.castUint8Array(uid)
          // pad Cascade Tag
          let uidtmp
          switch (uid.byteLength) {
            case 4:
              break
            case 7:
              uidtmp = new Uint8Array(8)
              for (let i = 0; i < 7; i++) uidtmp[i + 1] = uid[i]
              uid[0] = 0x88
              uid = uidtmp
              break
            case 10:
              uidtmp = new Uint8Array(12)
              for (let i = 0; i < 10; i++) uidtmp[i + (i >= 3 ? 2 : 1)] = uid[i]
              ;[uid[0], uid[4]] = [0x88, 0x88]
              uid = uidtmp
              break
            default:
              throw new Error('invalid uid')
          }
        }
        const res = await this.inListPassiveTarget({ maxTg, brTy: 0, data: uid, timeout })
        const nbTg = res.data.getUint8(1)
        // find format: tg + atqa + sak + uidlen + uid (uidlen) + atslen + ats (atslen - 1)
        const format = _.find([
          [{ tg: 0, ats: 0 }, { tg: 0, ats: 0 }], // empty
          [{ tg: 1, ats: 0 }, { tg: 0, ats: 0 }], // tg1
          [{ tg: 1, ats: 1 }, { tg: 0, ats: 0 }], // tg1 + ats1
          [{ tg: 1, ats: 0 }, { tg: 1, ats: 0 }], // tg1 + tg2
          [{ tg: 1, ats: 1 }, { tg: 1, ats: 0 }], // tg1 + ats1 + tg2
          [{ tg: 1, ats: 0 }, { tg: 1, ats: 1 }], // tg1 + tg2 + ats2
          [{ tg: 1, ats: 1 }, { tg: 1, ats: 1 }], // tg1 + ats1 + tg2 + ats2
        ], tmp => {
          try {
            if (tmp[0].tg + tmp[1].tg !== nbTg) return false
            tmp[0].st = 2 // start pos
            tmp[0].tg = res.data.getUint8(tmp[0].st + 4) + 5
            if (!_.includes([4, 7, 10], tmp[0].tg - 5)) return false
            // ATS Length byte is counted in ATS Frame
            if (tmp[0].ats) tmp[0].ats = res.data.getUint8(tmp[0].st + tmp[0].tg)
            if (tmp[1].tg) {
              tmp[1].st = tmp[0].st + tmp[0].tg + tmp[0].ats // start pos
              tmp[1].tg = res.data.getUint8(tmp[1].st + 4) + 5
              if (!_.includes([4, 7, 10], tmp[1].tg - 5)) return false
              // ATS Length byte is counted in ATS Frame
              if (tmp[1].ats) tmp[1].ats = res.data.getUint8(tmp[1].st + tmp[1].tg)
            }
            return tmp[0].tg + tmp[0].ats + tmp[1].tg + tmp[1].ats + 2 === res.data.byteLength
          } catch (err) {
            return false
          }
        })
        if (!format) throw new Error('failed to find targets format')
        return _.times(nbTg, i => {
          const { ats, st, tg } = format[i]
          return {
            tg: res.data.getUint8(st),
            atqa: `000${res.data.getUint16(st + 1).toString(16)}`.slice(-4),
            sak: this.dvGetHex(res.data, st + 3),
            uid: new Uint8Array(res.buffer, res.data.byteOffset + st + 5, tg - 5),
            ...(ats === 0 ? {} : { ats: new Uint8Array(res.buffer, res.data.byteOffset + st + tg, ats) }),
          }
        })
      }

      async hf14a4IsPresent () {
        // Diagnose06 failed completely with a JCOP31 on a PN532 so let's do it manually
        let isPresent = false
        for (let retry = 0; retry < 3; retry++) {
          try {
            await this.inCommunicateThru({ data: 'b2' })
            isPresent = true
            break
          } catch (err) {}
        }
        return isPresent
      }

      async inDataExchange ({ tg = 1, data = null, timeout = 2e3 } = {}) {
        data = this.castUint8Array(data)
        const frame = this.frameCreateNormal(3 + _.get(data, 'byteLength', 0)) // include len of TFI
        frame.u8.set(new Uint8Array([0x40, tg]), frame.data.byteOffset)
        if (data) frame.u8.set(data, frame.data.byteOffset + 2) // data out
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame, resTimeout: timeout })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
        return {
          status,
          ...(res.len <= 3 ? {} : {
            data: new DataView(res.buffer, res.data.byteOffset + 2, res.len - 3),
          }),
        }
      }

      async inCommunicateThru ({ data = null, timeout = 3e3 } = {}) {
        if (!data) throw new Error('invalid data')
        data = this.castUint8Array(data)
        const frame = this.frameCreateNormal(2 + _.get(data, 'byteLength', 0)) // include len of TFI
        frame.data.setUint8(0, 0x42)
        frame.u8.set(data, frame.data.byteOffset + 1)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame, resTimeout: timeout })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
        return {
          status,
          ...(res.len <= 3 ? {} : {
            data: new DataView(res.buffer, res.data.byteOffset + 2, res.len - 3),
          }),
        }
      }

      async inDeselect ({ tg = 0 } = {}) {
        if (_.isNil(tg)) throw new Error('invalid tg')
        const frame = this.frameCreateNormal(3) // include len of TFI
        frame.u8.set(new Uint8Array([0x44, tg]), frame.data.byteOffset)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
      }

      async inRelease ({ tg = 0 } = {}) {
        if (_.isNil(tg)) throw new Error('invalid tg')
        const frame = this.frameCreateNormal(3) // include len of TFI
        frame.u8.set(new Uint8Array([0x52, tg]), frame.data.byteOffset)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
      }

      async inSelect ({ tg = 1 } = {}) {
        if (!_.includes([1, 2], tg)) throw new Error('invalid tg')
        const frame = this.frameCreateNormal(3) // include len of TFI
        frame.u8.set(new Uint8Array([0x54, tg]), frame.data.byteOffset)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame })
        const status = res.data.getUint8(1)
        this.throwStatusIfFailed(status)
      }

      async inAutoPoll ({ pollNr, period, types = [], timeout } = {}) {
        if (!_.isArray(types) || !types.length) throw new Error('invalid types')
        const frame = this.frameCreateNormal(4 + types.length) // include len of TFI
        frame.u8.set(new Uint8Array([0x60, pollNr, period, ...types]), frame.data.byteOffset)
        this.frameGenerateDCS(frame)
        const res = await this.frameExec({ frame, resTimeout: timeout })
        // TODO: parse response
        return {
          nbTg: res.data.getUint8(1),
          ...(res.len <= 3 ? {} : {
            data: new DataView(res.buffer, res.data.byteOffset + 2, res.len - 3),
          }),
        }
      }

      async wakeup () {
        const frame = this.frameCreateFromHex('55550000000000000000000000000000ff03fdd414011700')
        await this.frameExec({ frame })
      }

      async deviceSelect () {
        if (this.device) return
        if (!await this.getBluetoothAvailability()) throw new Error('WebBLE not supported')
        this.device = await navigator.bluetooth.requestDevice({
          filters: [{ name: 'JDY-33-BLE' }],
          optionalServices: [this.uuidServ],
        })
        if (!this.device) throw new Error('no device')
        this.logTime(`device selected, name = ${this.device.name}, id = ${this.device.id}`)
      }

      deviceOnDisconnect () {
        this.logTime('device disconnected')
        if (this.charRecv) {
          if (this.isGattConnected()) this.charRecv.stopNotifications()
          this.charRecv.removeEventListener('characteristicvaluechanged', this.gattOnReceive)
          this.charRecv = null
        }
        if (this.charSend) this.charSend = null
        if (this.service) this.service = null
        if (this.device) {
          this.device.removeEventListener('gattserverdisconnected', this.deviceOnDisconnect)
          if (this.isGattConnected()) this.device.gatt.disconnect()
        }
      }

      async gattConnect () {
        if (this.isGattConnected()) return

        const { uuidServ, uuidSend, uuidRecv } = this
        await this.deviceSelect()

        for (let i = 0; !this.isGattConnected() && i < 3; i++) {
          try {
            this.logTime(`try to connect gatt (${i + 1})`)
            await this.device.gatt.connect()
            await this.sleep(500)
          } catch (err) {
            console.error(errToPlainObj(err))
          }
        }
        if (!this.isGattConnected()) throw new Error('Failed to connect gatt')

        this.device.addEventListener('gattserverdisconnected', this.deviceOnDisconnect.bind(this))
        this.service = await this.device.gatt.getPrimaryService(uuidServ)
        this.charSend = await this.service.getCharacteristic(uuidSend)
        this.charRecv = await this.service.getCharacteristic(uuidRecv)
        this.charRecv.addEventListener('characteristicvaluechanged', this.gattOnReceive.bind(this))
        await this.charRecv.startNotifications()
        await this.wakeup()
      }

      isGattConnected () {
        return _.get(this, 'device.gatt.connected')
      }

      frameCreateNormal (len) {
        if (!_.inRange(len, 1, 0x100)) throw new Error('invalid len')
        const buffer = new ArrayBuffer(len + 7)
        const frame = {
          buffer,
          data: new DataView(buffer, 6, len - 1), // exclude TFI
          dv: new DataView(buffer),
          len,
          u8: new Uint8Array(buffer),
        }
        // Octet 0: PREAMBLE
        // Octet 1~2: Start Code
        // Octet 3: len
        // Octet 4: LCS
        // Octet 5: TFI
        frame.u8.set(new Uint8Array([0xFF, len, -len, 0xD4]), 2)
        return frame
      }

      frameCreateExtended (len) {
        if (!_.inRange(len, 0x100, 0x10000)) throw new Error('invalid len')
        const buffer = new ArrayBuffer(len + 10)
        const frame = {
          buffer,
          data: new DataView(buffer, 9, len - 1), // exclude TFI
          dv: new DataView(buffer),
          len,
          u8: new Uint8Array(buffer),
        }
        // Octet 0: PREAMBLE
        // Octet 1~2: Start Code
        // Octet 3~4: Fixed 0xFF
        // Octet 5~6: LenM, LenL
        // Octet 7: LCS
        // Octet 8: TFI
        const lenM = (len >> 8); const lenL = (len & 0xFF)
        frame.u8.set(new Uint8Array([0xFF, 0xFF, 0xFF, lenM, lenL, (0 - lenM - lenL), 0xD4]), 2)
        return frame
      }

      frameCreateFromHex (hex) {
        const u8 = this.castUint8Array(hex)
        const frame = {
          buffer: u8.buffer,
          dv: new DataView(u8.buffer),
          u8,
        }
        // find frame start
        let st = 0
        while (st < u8.length - 1 && frame.dv.getUint16(st) !== 0x00FF) st++
        if (st < u8.length - 1) { // frame start found
          // normal frame
          if ((u8[st + 2] + u8[st + 3]) % 256 === 0) {
            frame.len = u8[st + 2]
            frame.data = new DataView(u8.buffer, st + 5, frame.len - 1)
          } else if ((u8[st + 4] + u8[st + 5] + u8[st + 6]) % 256 === 0) {
            frame.len = frame.dv.getUint16(st + 5)
            frame.data = new DataView(u8.buffer, st + 8, frame.len - 1)
          }
        }
        return frame
      }

      frameGenerateDCS (frame) {
        // DCS: data checksum
        const dcs = frame.u8.length - 2
        frame.u8[dcs] = 0
        for (let i = 0; i < frame.len; i++) frame.u8[dcs] -= frame.u8[dcs - i - 1]
      }

      async frameExec ({ frame, ackTimeout = 1000, resTimeout = 1000 }) {
        await this.gattConnect()
        // 避免重複執行
        if (this.ackHandlers || this.resHandlers) throw new Error('有其他 BLE 指令正在執行')
        // 把 resolve 跟 reject 丟到全域去
        const pending = { ack: null, res: null }
        if (ackTimeout) pending.ack = new Promise((resolve, reject) => { this.ackHandlers = { resolve, reject } })
        if (resTimeout) pending.res = new Promise((resolve, reject) => { this.resHandlers = { resolve, reject, cmd: frame.data ? frame.data.getUint8(0) + 1 : null } })
        try {
          // logTime
          this.logTime(`傳送: ${this.inspectFrame(frame)}`)
          await this.charSend.writeValue(frame.buffer)
          await this.timeout(pending.ack, ackTimeout, '傳送超時')
          if (resTimeout) return await this.timeout(pending.res, resTimeout, '回應超時')
        } finally {
          this.ackHandlers = null
          this.resHandlers = null
        }
      }

      u8FromHex (hex) {
        return new Uint8Array(_.map(hex.match(/.{2}/g), b => _.parseInt(b, 16)))
      }

      u8FromUtf8 (utf8) {
        if (!_.isString(utf8)) throw new Error('utf8 is required')
        return new Uint8Array((new TextEncoder()).encode(utf8).buffer)
      }

      u8ToUtf8 (data) {
        data = this.castUint8Array(data)
        if (!data) throw new Error('data is required')
        return (new TextDecoder('utf-8')).decode(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength))
      }

      async gattOnReceive (event) {
        const buffer = _.get(event, 'target.value.buffer')
        const res = { buffer, dv: new DataView(buffer), u8: new Uint8Array(buffer) }

        // ack / nack frame
        if (res.u8.length === 6) {
          const isAck = (this.bufferCmp(buffer, FRAME_ACK) === 0)
          if (isAck) _.invoke(this, 'ackHandlers.resolve', res)
          else {
            const err = new Error('invalid ack')
            _.set(err, 'data.res', res)
            this.logTime(err.message)
            _.invoke(this, 'ackHandlers.reject', err)
          }
          return
        }

        this.logTime(`收到: ${this.inspectFrame(buffer)}`)
        try {
          const isNormalFrame = res.u8.length <= 262
          // LCS: len checksum
          if ((isNormalFrame ? (res.u8[3] + res.u8[4]) : (res.u8[5] + res.u8[6] + res.u8[7])) % 256 !== 0) throw new Error('invalid lcs')
          res.len = isNormalFrame ? res.u8[3] : (res.u8[5] * 256 + res.u8[6])
          // DCS: data checksum
          let dcs = 0
          for (let i = 0; i <= res.len; i++) dcs += res.u8[res.u8.length - i - 2]
          if (dcs % 256) throw new Error(`invalid dcs = ${dcs}`)
          if (res.u8.length === 8) throw new Error(`Error frame: ${this.dvGetHex(res.dv, 5)}`)
          res.data = new DataView(buffer, res.u8.length - res.len - 1, res.len - 1)
          if (res.u8[res.data.byteOffset - 1] !== 0xd5) throw new Error('invalid TFI')
          if (!_.isNil(_.get(this, 'resHandlers.cmd')) && this.resHandlers.cmd !== res.data.getUint8(0)) throw new Error('response cmd mismatch')
          return _.invoke(this, 'resHandlers.resolve', res)
        } catch (err) {
          _.set(err, 'data.res', res)
          this.logTime(err.message)
          return _.invoke(this, 'resHandlers.reject', err)
        }
      }

      sleep (t) {
        return new Promise(resolve => setTimeout(resolve, t))
      }

      async timeout (promise, timeout, message) {
        return await Promise.race([
          promise,
          (async () => {
            await this.sleep(timeout)
            throw new Error(`${message} (${timeout}ms)`)
          })(),
        ])
      }

      logTime (text) {
        console.log(`[${new Date().toTimeString().slice(0, 8)}] ${text}`)
      }

      inspectBuffer (data) {
        data = this.castUint8Array(data)
        return _.join(_.map(data, num => `0${num.toString(16)}`.slice(-2)), ' ')
      }

      inspectFrame (frame) {
        if (frame instanceof ArrayBuffer) frame = this.frameCreateFromHex(frame)
        if (!frame.buffer) throw new Error('invalid frame')
        if (!this.verbose && frame.data) return this.inspectBuffer(new Uint8Array(frame.buffer, frame.data.byteOffset, frame.data.byteLength))
        return this.inspectBuffer(frame.buffer)
      }

      async getBluetoothAvailability () {
        return await _.invoke(navigator, 'bluetooth.getAvailability')
      }

      bufferCmp (a, b) {
        ;[a, b] = [this.castUint8Array(a), this.castUint8Array(b)]

        if (a.byteLength !== b.byteLength) return a.byteLength - b.byteLength
        let i = a.byteLength
        while (i--) if (a[i] !== b[i]) return a[i] - b[i]
        return 0
      }

      dvGetHex (dv, byteOffset) {
        if (dv instanceof ArrayBuffer) dv = new DataView(dv)
        if (!(dv instanceof DataView)) dv = new DataView(dv.buffer, dv.byteOffset, dv.byteLength)
        return `0${dv.getUint8(byteOffset).toString(16)}`.slice(-2)
      }

      throwStatusIfFailed (status = 0) {
        const code = `0${(status & 0x3f).toString(16)}`.slice(-2)
        if (ERROR_CODE[code]) throw new Error(`NAD = ${(status & 0x80) ? 1 : 0}, MI = ${(status & 0x40) ? 1 : 0}, code = ${code}, msg = ${ERROR_CODE[code]}`)
      }

      castUint8Array (data) {
        if (_.isString(data)) data = this.u8FromHex(data)
        if (data instanceof ArrayBuffer) data = new Uint8Array(data)
        if (data && !(data instanceof Uint8Array)) data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)
        return data
      }
    }
    return Pn532
  }))

  ;(function (root, factory) { // amdWebGlobal
    if (!(typeof define === 'function' && define.amd)) return (root.Pn532M1 = factory(root._, root.Pn532))
    define(['_', 'Pn532'], (_, Pn532) => (root.Pn532M1 = factory(_, Pn532)))
  }(typeof self !== 'undefined' ? self : this, (_, Pn532) => {
    class Pn532M1 {
      constructor (pn532) {
        if (!(pn532 instanceof Pn532)) throw new TypeError('pn532 instance is required')
        this.pn532 = pn532
      }

      async authBlock ({ block = 0, isKeyB = 0, key = null, tg = 1, uid = null } = {}) {
        if (!key) throw new Error('key is required')
        if (!uid) throw new Error('uid is required')
        const { pn532 } = this
        ;[key, uid] = [pn532.castUint8Array(key), pn532.castUint8Array(uid)]
        if (key.byteLength !== 6) throw new Error('invalid key length')
        if (uid.byteLength !== 4) throw new Error('invalid uid length')
        return await pn532.inDataExchange({
          tg,
          data: new Uint8Array([
            isKeyB ? 0x61 : 0x60, // Authentication B = 0x61, Authentication A = 0x60
            block, // Block Number (1K = 0..63, 4K = 0..255)
            ...key,
            ...uid,
          ]),
        })
      }

      async readBlock ({ block = 0, tg = 1 } = {}) {
        const { pn532 } = this
        return await pn532.inDataExchange({
          tg,
          data: new Uint8Array([
            0x30, // Mifare Read command = 0x30
            block, // Block Number (1K = 0..63, 4K = 0..255)
          ]),
        })
      }

      async writeBlock ({ block = 0, tg = 1, data = null } = {}) {
        if (!data) throw new Error('data is required')
        const { pn532 } = this
        data = pn532.castUint8Array(data)
        if (data.byteLength !== 16) throw new Error('invalid data length')
        return await pn532.inDataExchange({
          tg,
          data: new Uint8Array([
            0xa0, // Mifare Write command = 0xA0
            block, // Block Number (1K = 0..63, 4K = 0..255)
            ...data,
          ]),
        })
      }

      async magicSetCrc (enable = 1) {
        enable = enable ? 0x80 : 0x00
        const { pn532 } = this
        // 0x6302 CIU_TxMode bit7 TxCRCEn, 0x6303 CIU_RxMode bit7 RxCRCEn
        await pn532.writeRegisters({ 0x6302: enable, 0x6303: enable })
      }

      async magicUnlock ({ tg = 1 } = {}) {
        // https://github.com/RfidResearchGroup/proxmark3/blob/dbec6edfa7e411e09b26946ac52e6b7e37225e85/doc/magic_cards_notes.md#mifare-classic-block0
        try {
          const { pn532 } = this
          // 08 63 02 00 63 03 00
          await this.magicSetCrc(0)
          await pn532.inSelect({ tg })
          // 42 50 00 57 CD (halt)
          await pn532.inCommunicateThru({ data: '500057CD' }).catch(() => 0)
          // 08 63 3D 07 (0x633d CIU_BitFraming TxLastBits 7)
          await pn532.writeRegisters({ 0x633d: 0x07 })
          // 42 40
          await pn532.inCommunicateThru({ data: '40' })
          // 08 63 3D 00 (0x633d CIU_BitFraming TxLastBits 0)
          await pn532.writeRegisters({ 0x633d: 0x00 })
          // 42 43
          await pn532.inCommunicateThru({ data: '43' })
        } finally {
          // 08 63 02 80 63 03 80
          await this.magicSetCrc(1)
        }
      }

      async magicSetUid ({ atqa = null, sak = null, tg = 1, uid = null } = {}) {
        const { pn532 } = this
        const block0 = pn532.castUint8Array(_.get(await this.readBlock({ tg, block: 0 }).catch(() => 0), 'data', '0102030404080400000000000000BEAF'))
        const block0dv = new DataView(block0.buffer)
        if (uid) {
          uid = pn532.castUint8Array(uid)
          if (!_.includes([4, 7, 10], uid.byteLength)) throw new Error('invalid uid length')
          block0.set(uid)
          const uidlen = uid.byteLength
          // bcc
          block0[uidlen] = 0
          for (let i = 0; i < uidlen; i++) block0[uidlen] ^= block0[i]
          if (!_.isNil(sak)) block0dv.setUint8(uidlen + 1, sak)
          if (!_.isNil(atqa)) block0dv.setUint16(uidlen + 2, atqa, true)
        }
        let isWriteFailed = true
        for (let retry = 0; retry < 3; retry++) {
          try {
            await this.writeBlock({ tg, block: 0, data: block0 })
            isWriteFailed = false
            break
          } catch (err) {}
        }
        if (isWriteFailed) pn532.logTime('magicSetUid failed')
      }

      async magicWipe ({ atqa = null, sak = null, tg = 1, uid = null } = {}) {
        const blockData = this.u8FromHex('00000000000000000000000000000000')
        const blockKey = this.u8FromHex('FFFFFFFFFFFF08778F00FFFFFFFFFFFF')

        await this.magicSetUid({ atqa, sak, tg, uid })
        for (let block = 1; block < 64; block++) { // skip block 0
          let isWriteFailed = true
          for (let retry = 0; retry < 3; retry++) {
            try {
              await this.mfWriteBlock({ tg, block, data: (block + 1) % 4 ? blockData : blockKey })
              isWriteFailed = false
              break
            } catch (err) {}
          }
          if (isWriteFailed) this.logTime(`magicWipe failed on block ${block}`)
        }
      }
    }
    return Pn532M1
  }))

  ;(function (root, factory) { // amdWebGlobal
    if (!(typeof define === 'function' && define.amd)) return (root.Pn532Waveshare = factory(root._, root.Pn532))
    define(['_', 'Pn532'], (_, Pn532) => (root.Pn532Waveshare = factory(_, Pn532)))
  }(typeof self !== 'undefined' ? self : this, (_, Pn532) => {
    class Pn532Waveshare {
      constructor (pn532) {
        if (!(pn532 instanceof Pn532)) throw new TypeError('pn532 instance is required')
        this.pn532 = pn532
      }

      async sendCmd ({ data = null, timeout = 5e3 }) {
        const { pn532 } = this
        data = pn532.castUint8Array(data)
        if (!data) throw new Error('invalid data')
        for (let i = 3; i > 0; i--) {
          try {
            const ret = await pn532.inCommunicateThru({ timeout, data: new Uint8Array([0xcd, ...data.values()]) })
            if (!ret.data || ret.data.byteLength !== 2) throw new Error('unexpected return value')
            return ret.data.getUint16(0, true) // littleEndian
          } catch (err) {
            pn532.logTime(`retry with error: ${err.message}`)
            if (i === 1) throw err
          }
        }
      }

      async waitUpdateReady (cmd) {
        const { pn532 } = this
        for (let i = 0; i < 100; i++) {
          try {
            const status = await this.sendCmd({ data: cmd })
            if (status === 0xff) return
            await pn532.sleep(25)
          } catch (err) {}
        }
        throw new Error('wait update ready failed')
      }

      async update_1_54b () {
        const { pn532 } = this
        try {
          await pn532.rfSetTimeouts([0x10, 0x10]) // timeout 3.28s
          console.log(_.first(await pn532.hf14aListPassiveTarget({ timeout: 3e4 })))

          for (const cmd of [
            ['0d', 0],
            ['00', 50],
            ['01', 10],
            ['02', 10],
            ['03', 10],
          ]) {
            if (await this.sendCmd({ data: cmd[0] })) throw new Error(`cmd 0xcd${cmd[0]}`)
            if (cmd[1]) await pn532.sleep(cmd[1])
          }
          const bitmap = new Uint8Array([ // sample data
            0x05, 100,
            ..._.times(100, i => [0xff, 0x00][i & 1]),
          ])
          // black
          for (let i = 0; i < 50; i++) {
            if (await this.sendCmd({ data: bitmap })) throw new Error('black bitmap')
          }
          if (await this.sendCmd({ data: new Uint8Array([0x04]) })) throw new Error('cmd 0xcd04')
          // red
          for (let i = 0; i < 50; i++) {
            if (await this.sendCmd({ data: bitmap })) throw new Error('red bitmap')
          }
          if (await this.sendCmd({ data: new Uint8Array([0x06]) })) throw new Error('cmd 0xcd06')
          pn532.logTime('sleep 1s')
          await pn532.sleep(1e3) // 10s
          await pn532.rfSetTimeouts([0x09, 0x09]) // timeout 25ms
          await this.waitUpdateReady('08') // waitUpdateReady
          if (await this.sendCmd({ data: new Uint8Array([0x04]) })) throw new Error('cmd 0xcd04')
        } catch (err) {
          pn532.logTime(`update failed: ${err.message}`)
          throw err
        } finally {
          await pn532.inRelease()
        }
      }
    }
    return Pn532Waveshare
  }))
