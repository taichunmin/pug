extends /layout/bootstrapV4

block beforehtml
  - const title = 'Binance WOTD'

block style
  meta(property="fb:app_id", content="2133031763635285")
  meta(property="og:description", content="Binance WOTD 猜字遊戲的輔助工具")
  meta(property="og:image:height", content="640")
  meta(property="og:image:width", content="1280")
  meta(property="og:image", content="https://i.imgur.com/8FCoTo8.png")
  meta(property="og:locale", content="zh_TW")
  meta(property="og:site_name", content="筆記國度")
  meta(property="og:title", content=title)
  meta(property="og:type", content="website")
  meta(property="og:url", content="https://taichunmin.idv.tw/pug/binance-wotd.html")
  style
    :sass
      [v-cloak]
        display: none
      body, .h1, .h2, .h3, .h4, .h5, .h6, h1, h2, h3, h4, h5, h6
        font-family: 'Noto Sans TC', sans-serif
      .letter-spacing-n1px
        &, .btn, textarea, select, input
          letter-spacing: -1px
      .text-sm
        font-size: 0.875rem

block content
  #app.container.my-4.text-monospace(v-cloak)
    h3.my-3.mb-0.text-center= title
    .card.mb-3
      h6.card-header 輸入猜測及比對結果 #[span.badge.badge-pill.badge-primary {{ ls.wordLen }}]
      ul.list-group.list-group-flush
        li.list-group-item
          .row.mx-n1
            .col.px-1: button.btn.btn-sm.btn-block.btn-outline-danger(@click="btnNewSolver(false)") #[i.fa.fa-fw.fa-refresh] 重設及改字數
            .col.px-1: button.btn.btn-sm.btn-block.btn-outline-primary(@click="btnLoadDict") #[i.fa.fa-fw.fa-cloud-download] 載入預設詞庫
          .text-sm.text-muted.letter-spacing-n1px.mt-2 詞庫網址: #[a(target="_blank", href="https://gist.github.com/taichunmin/e3a6a7b504bc416e36c0cb8aa2f2c7ec") https://gist.github.com/taichunmin/e3a6a7b504bc416e36c0cb8aa2f2c7ec]
        li.list-group-item(v-for="(solver, solverId) in ss.solvers")
          .input-group.input-group-sm.mb-2.letter-spacing-n1px
            .input-group-prepend: span.input-group-text {{ solverId + 1 }}
            input.form-control(type="text", v-model="solver.guess")
            .input-group-append: button.btn.btn-outline-secondary(@click="solver.guess = ''") #[i.fa.fa-fw.fa-times]
          .d-flex.flex-row.justify-content-between.align-items-center(role="toolbar")
            .d-block.my-0 比對結果
            .btn-group.btn-group-sm(role="group")
              button.btn.btn-outline-dark(v-for="v, k of solver.simiArr", @click="$set(solver.simiArr, k, (v+1)%3)")
                i.fa.fa-square(:class="`text-${['muted', 'warning', 'success'][v]}`")
    .card.mb-3
      h6.card-header 輔助猜題 #[span.badge.badge-pill.badge-primary {{ candidates.length }}]
      .card-body
        .form-group
          .my-1 找可能的謎底 #[span.badge.badge-pill.badge-success {{ result.possibles.length }}]
          small.my-1.form-text.text-muted(v-if="result.possibles.length > 50") 僅顯示前 50 筆
          #possibles
            span.badge.badge-info.mr-1(v-for="word in _.take(result.possibles, 50)", @click="btnCopy(word)") {{ word }}
        .form-group.mb-0
          .my-1 找可能的字母 #[span.badge.badge-pill.badge-success {{ result.incorrectLetters.length }}]
          small.my-1.form-text.text-muted(v-if="result.incorrectLetters.length > 50") 僅顯示前 50 筆
          #incorrectLetters
            span.badge.badge-info.mr-1(v-for="word in _.take(result.incorrectLetters, 50)", @click="btnCopy(word)") {{ word }}
    .input-group.input-group-sm.mb-3.letter-spacing-n1px
      .input-group-prepend: span.input-group-text Words
      textarea.form-control(v-model="ss.article", rows="5")
      .input-group-append: button.btn.btn-outline-secondary(@click="ss.article = ''") #[i.fa.fa-fw.fa-times]
    .modal.fade(tabindex="-1", ref="wordLenPicker")
      .modal-dialog.modal-dialog-centered.modal-xl
        .modal-content
          .modal-header
            h5.modal-title #[i.fa.fa-fw.fa-floppy-o] 請選擇字數
            button.close(type="button", data-dismiss="modal") #[span &times;]
          .modal-body
            a.btn.btn-block.btn-outline-primary.mb-2(
              v-for="n in [3,4,5,6,7,8]"
              @click="wordLenPicker.cb?.(n)"
            ) {{ n }} 個字母

block script
  script(type="module").
    window.vm = new Vue({
      el: '#app',
      data: {
        wordLenPicker: { cb: null },
        ls: {
          wordLen: 7,
        },
        ss: {
          article: '',
          solvers: [],
        },
      },
      async mounted () {
        // 自動儲存功能
        for (const [storage, key] of [[localStorage, 'ls'], [sessionStorage, 'ss']]) {
          try {
            const saved = JSON5.parse(storage.getItem(location.pathname))
            if (saved) this.$set(this, key, _.merge({}, this[key], saved))
          } catch (err) {}
          this.$watch(key, () => {
            storage.setItem(location.pathname, JSON5.stringify(this[key]))
          }, { deep: true })
        }
        if (!this.ss.solvers.length) this.btnNewSolver(true)
      },
      computed: {
        candidates () {
          try {
            const { ls: { wordLen }, ss: { article } } = this
            let words = _.chain(article.split(/\s+/))
              .map(_.toLower)
              .map(word => word.replaceAll(/[^a-zA-Z]/g, ''))
              .filter(word => word.length === wordLen)
              .uniq()
              .value()
            if (words.length < 1) return []
            const letterCnt = new Map()
            for (const word of words) {
              for (const letter of word) letterCnt.set(letter, (letterCnt.get(letter) ?? 0) + 1)
            }
            words = _.orderBy(words, [
              word => _.uniq(word.split('')).length,
              word => _.sumBy(_.uniq(word.split('')), l => letterCnt.get(l) ?? 0),
              word => word,
            ], ['desc', 'desc', 'asc'])
            // console.log(words)
            return words
          } catch (err) {
            return []
          }
        },
        validSolvers () {
          const wordLen = this.ls.wordLen
          return _.compact(_.map(this.ss.solvers, solver => {
            if (solver.guess.length !== wordLen) return null
            return { ...solver, guess: _.toLower(solver.guess) }
          }))
        },
        result () {
          const candidates = this.candidates
          const wordLen = this.ls.wordLen
          const solvers = _.map(this.validSolvers, solver => ({
            ...solver,
            simi: this.simiArrToInt(solver.simiArr),
          }))

          if (solvers.length < 1) {
            return { possibles: candidates, incorrectLetters: [] }
          }

          // 計算可能的謎底
          const possibles = _.filter(candidates, word => _.every(solvers, solver => this.simiArrToInt(this.simiCmp(solver.guess, word)) === solver.simi))

          // 計算可能謎底的字母出現次數 (忽略綠燈位置)
          const posHasGreen = _.times(wordLen, i => _.some(solvers, solver => solver.simiArr[i] === 2))
          const possiblesLetterCnt = new Map()
          for (let i = 0; i < wordLen; i++) {
            if (posHasGreen[i]) continue
            for (const word of possibles) {
              const l = word[i]
              possiblesLetterCnt.set(l, (possiblesLetterCnt.get(l) ?? 0) + 1)
            }
          }
          // console.log(`possiblesLetterCnt = ${JSON.stringify([...possiblesLetterCnt.entries()])}`)

          const incorrectLetters = _.chain(candidates)
            .map(word => {
              const tmp = _.uniq(word.split(''))
              return [
                word,
                _.sumBy(tmp, l => possiblesLetterCnt.has(l) ? 1 : 0), // 字母有出現在可能謎底中的數量
                _.sumBy(tmp, l => possiblesLetterCnt.get(l) ?? 0), // 字母在可能謎底中出現的頻繁程度
              ]
            })
            .filter(([,, letterCntSum]) => letterCntSum > 0)
            .orderBy([1, 2, 0], ['desc', 'desc', 'asc'])
            .map(0)
            .value()

          return { possibles, incorrectLetters }
        },
      },
      methods: {
        async btnNewSolver (force = false) {
          if (!force && !await this.confirm('是否重設及修改字數？')) return
          const $ref = window.jQuery(this.$refs.wordLenPicker)
          const newVal = await new Promise(resolve => {
            this.$set(this, 'wordLenPicker', { cb: resolve })
            $ref.one('hide.bs.modal', () => resolve()).modal('show')
          })
          $ref.modal('hide')
          this.$set(this.wordLenPicker, 'cb', null)
          if (_.isNil(newVal)) return

          this.ls.wordLen = newVal
          this.$set(this.ss, 'solvers', _.times(6, () => ({
            guess: '',
            simiArr: _.times(this.ls.wordLen, () => 0),
          })))
          await this.btnLoadDict()
        },
        async btnLoadDict () {
          try {
            this.showLoading({ text: '載入預設詞庫' })
            const wordLen = this.ls.wordLen
            const dict = (await axios.get(`https://gist.githubusercontent.com/taichunmin/e3a6a7b504bc416e36c0cb8aa2f2c7ec/raw/${wordLen}.txt`))?.data
            if (_.isEmpty(dict)) throw new Error('詞庫為空')
            this.ss.article = dict
            await Swal.fire({ icon: 'success', title: '載入預設詞庫成功' })
          } catch (err) {
            console.log(err)
            await this.swalFire({ icon: 'error', title: '載入失敗', text: err.message })
          }
        },
        verifyGuess (guess) {
          if (guess.length !== this.ls.wordLen) return false
          return true
        },
        simiCmp (guess, answer) {
          // guess = 'freshed', answer = 'service', flags = [0, 1, 1, 1, 0, 1, 0]
          const wordLen = answer.length
          const flags = _.times(wordLen * 2, () => 0)
          for (let i = 0; i < wordLen; i++) {
            if (guess[i] === answer[i]) flags[i] = flags[wordLen + i] = 2
          }
          for (let i = 0; i < wordLen; i++) {
            if (flags[i]) continue
            for (let j = 0; j < wordLen; j++) {
              if (i === j || flags[wordLen + j] || guess[i] !== answer[j]) continue
              flags[i] = flags[wordLen + j] = 1
              break
            }
          }
          return flags.slice(0, wordLen)
        },
        simiArrToInt (simiArr) {
          let simi = 0
          for (let tmp of simiArr) simi = simi * 4 + tmp + 1
          return simi
        },
        promiseWithResolvers () {
          let resolve, reject
          const promise = new Promise((res, rej) => { resolve = res; reject = rej })
          return { promise, reject, resolve }
        },
        async confirm (text, confirmButtonText = '是', cancelButtonText = '否') {
          return await new Promise((resolve, reject) => {
            let isConfirmed = false
            const args = {
              cancelButtonColor: '#3085d6',
              cancelButtonText,
              confirmButtonColor: '#d33',
              confirmButtonText,
              didDestroy: () => { resolve(isConfirmed) },
              focusCancel: true,
              icon: 'warning',
              reverseButtons: true,
              showCancelButton: true,
              text,
            }
            Swal.fire(args).then(res => { isConfirmed = res.isConfirmed })
          })
        },
        showLoading (opts = {}) {
          opts = {
            allowOutsideClick: false,
            showConfirmButton: false,
            ...opts,
          }
          if (Swal.isVisible()) return Swal.update(_.omit(opts, ['progressStepsDistance']))
          Swal.fire({ ...opts, didRender: () => { Swal.showLoading() } })
        },
        async btnCopy (text, container = null) {
          if (!container) container = document.body
          const dom = document.createElement('textarea')
          dom.value = text
          container.appendChild(dom)
          dom.select()
          dom.setSelectionRange(0, 1e6) // For mobile devices
          document.execCommand('copy')
          container.removeChild(dom)
          await Swal.fire({ icon: 'success', title: '複製成功' })
        },
      },
    })
