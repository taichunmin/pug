extends /layout/bootstrapV4

block beforehtml
  - title = 'Amiibo Generator'

block style
  style
    :sass
      [v-cloak]
        display: none
      body, .h1, .h2, .h3, .h4, .h5, .h6, h1, h2, h3, h4, h5, h6
        font-family: 'Noto Sans TC', sans-serif
      .font-size-dot8
        font-size: 80%
      .input-group-prepend .input-group-text
        letter-spacing: -1px
        min-width: 8rem

block content
  #app.container.my-4.text-monospace(v-cloak)
    h3.my-3.text-center= title

block script
  script(crossorigin="anonymous", src="https://cdn.jsdelivr.net/npm/pn532.js@0.1.18/dist/Packet.min.js")
  script(crossorigin="anonymous", src="https://cdn.jsdelivr.net/npm/crypto-js@4/crypto-js.min.js")
  script.
    /* global Packet */
    ;(Packet => { // extend Packet
      Packet.fromWordArray = wordArray => {
        const { words, sigBytes } = wordArray
        const pack = new Packet(sigBytes)
        for (let i = 0; i < sigBytes; i++) pack[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xFF
        return pack
      }
      Packet.prototype.toWordArray = function () {
        const { lib: { WordArray } } = CryptoJS
        return new WordArray.init(this)
      }
    })(window.Packet)

    // see: https://firefox2100.github.io/proxmark3/2022/03/17/Amiibo_1/
    const RETAIL_KEY = Packet.fromBase64('HRZLN1typVcouR1ktqPCBXVuZml4ZWQgaW5mb3MAAA7bS54_RSePOX7_m0-5kwAABEkX3Ha0lkDW-Dk5lg-u1O85L6qyFCiqIftU5UUFR2Z_dS0oc6IAF_74XAV1kEttbG9ja2VkIHNlY3JldAAAEP3IoHaUuJ5MR9N96M5cdMEESRfcdrSWQNb4OTmWD67U7zkvqrIUKKoh-1TlRQVHZg') // UNFIXED_INFOS: 80 bytes + LOCKED_SECRET: 80 bytes
    class AmiiboNtag215 {
      constructor () {
        this.pack = new Packet(540)
        this.keys = null
      }

      static fromBin (input) {
        if (!Packet.isLen(input, 540)) throw new TypeError('input should be Packet')
        const dump = new AmiiboNtag215()
        dump.pack.set(input, 0) // clone
        return dump
      }

      static fromAmiibo (amiibo) {
        if (!_.isString(amiibo.id) || amiibo.id.length !== 16) throw new TypeError('invalid amiibo id')
        const dump = new AmiiboNtag215()
        dump.pack.setUint16(2, 0x0FE0, false)
        dump.pack.set(Packet.fromHex(amiibo.id), 476)
        dump.randomUid()
        return dump
      }

      static hs256 (pack, secret) {
        return Packet.fromWordArray(CryptoJS.HmacSHA256(pack.toWordArray(), secret.toWordArray()))
      }

      static aes128Ctr (pack, key, iv) {
        const encrypted = CryptoJS.AES.encrypt(pack.toWordArray(), key.toWordArray(), {
          iv: iv.toWordArray(),
          mode: CryptoJS.mode.CTR,
          padding: CryptoJS.pad.NoPadding,
        })
        return Packet.fromWordArray(encrypted.ciphertext)
      }

      static generateKeyBySeedAndRetailKey (baseSeed, retail) {
        const { hs256 } = AmiiboNtag215
        const seed = new Packet(baseSeed)
        seed.set(retail.subarray(16, 30), 2) // key type: LOCKED_SECRET or UNFIXED_INFOS
        if (retail[31] === 16) seed.set(retail.subarray(32, 48), 16) // 16 magic bytes
        else seed.set(retail.subarray(32, 46), 18) // 14 magic bytes
        for (let i = 0; i < 32; i++) seed[48 + i] ^= retail[48 + i] // xorPad
        //- console.log(`retail = ${retail.base64url}`)
        //- console.log(`seed = ${seed.base64url}`)
        const res = {}
        if (retail[31] === 14) [res.aesKey, res.aesIv] = hs256(seed, retail.subarray(0, 16)).chunk(16)
        seed[1] = 1
        res.secret = hs256(seed, retail.subarray(0, 16)).subarray(0, 16)
        return res
      }

      static parseDate (raw) { return `${(raw >>> 9) + 2000}-${(raw >>> 5) & 0x0F}-${(raw >>> 0) & 0x1F}` }

      get uid () { return this.pack.subarray(0, 8) } // UID + BCC0
      get sec1 () { return this.pack.subarray(8, 16) } // BCC1 + internal + lock bytes + Capability Container
      get setting () { return this.pack.subarray(16, 52) } // Tag setting
      get sign1 () { return this.pack.subarray(52, 84) } // Tag HS256
      get model () { return this.pack.subarray(84, 96) } // Amiibo Model Info
      get salt () { return this.pack.subarray(96, 128) } // Keygen Salt
      get sign2 () { return this.pack.subarray(128, 160) } // app data HS256
      get appData () { return this.pack.subarray(160, 520) } // app data
      get pwd () { return this.pack.subarray(532, 536) } // read pwd

      get payload1 () { // for sign1
        return Packet.merge(this.uid, this.model, this.salt)
      }

      get payload2 () { // for sign2
        return Packet.merge(this.setting.subarray(1), this.appData, this.sign1, this.payload1)
      }

      // https://github.com/hax0kartik/wumiibo/blob/master/source/AmiiboFile.cpp
      get flag () { return this.pack[44] }
      get parsedSetting () { // https://github.com/hax0kartik/wumiibo/blob/master/source/amiibo_structs.h
        if (!((this.flag >>> 4) & 1)) return undefined
        return {
          countryCodeId: this.pack[45], // Country Code ID, from the system which setup this amiibo.
          flag: this.flag & 0x0F, // See also the Amiibo_amiiboFlag enums.
          mii: this.pack.subarray(76, 172), // [0x4C, 0x4C + 0x60], Owner Mii.
          nickname: this.pack.subarray(56, 76), // [0x38, 0x38 + 0x14], UTF-16BE Amiibo nickname.
          lastWriteDate: AmiiboNtag215.parseDate(this.pack.getUint16(50, false)),
          setupDate: AmiiboNtag215.parseDate(this.pack.getUint16(48, false)),
        }
      }
      get parsedAppDataConfig () {
        if (!((this.flag >>> 5) & 1)) return undefined
        return {
          appId: this.pack.getUint32(182, false),
          counter: this.pack.getUint16(180, false),
          // Amiibo module writes hard-coded uint8_t value 0xD8 here. This is the size of the Amiibo AppData, apps can use this with the AppData R/W commands. ...
          data: this.pack.subarray(220, 436), // [0xDC, 0xDC + 0xD8]
          titleId: this.pack.subarray(172, 180), // BigUint64
          unk: this.flag >>> 4,
        }
      }

      generateKeys () {
        const LOCKED_SECRET = RETAIL_KEY.subarray(80) // for sign1
        const UNFIXED_INFOS = RETAIL_KEY.subarray(0, 80) // for sign2
        const { generateKeyBySeedAndRetailKey } = AmiiboNtag215
        const keys = {}
        const baseSeed = Packet.merge(
          new Packet(16),
          this.setting.subarray(1, 3), // 2 bytes: [17, 19]
          new Packet(14),
          this.uid,
          this.uid,
          this.salt,
        )
        //- console.log(`baseSeed = ${baseSeed.base64url}`)

        const key1 = generateKeyBySeedAndRetailKey(baseSeed, LOCKED_SECRET)
        keys.secret1 = key1.secret

        const key2 = generateKeyBySeedAndRetailKey(baseSeed, UNFIXED_INFOS)
        keys.secret2 = key2.secret
        keys.aesKey = key2.aesKey
        keys.aesIv = key2.aesIv
        return keys
      }

      encryptOrDecrypt () {
        const payloadCfgs = [
          [20, 52], // setting [start + 4, end] 32 bytes
          [160, 520], // app data [start, end] 360 bytes
        ]
        const { aesKey, aesIv } = this.keys
        //- console.log(`aesKey = ${aesKey.base64url}, aesIv = ${aesIv.base64url}`)
        const payload = Packet.merge(..._.map(payloadCfgs, cfg => this.pack.subarray(...cfg)))
        //- console.log(`encrypt.before = ${payload.base64url}`)
        const encrypted = AmiiboNtag215.aes128Ctr(payload, aesKey, aesIv)
        //- console.log(`encrypt.after = ${encrypted.base64url}`)
        let offset = 0
        for (const [start, end] of payloadCfgs) {
          const len = end - start
          this.pack.set(encrypted.subarray(offset, offset + len), start)
          offset += len
        }
      }

      isValid () {
        const { hs256 } = AmiiboNtag215
        const bak = new Packet(this.pack)
        this.keys = this.generateKeys()
        this.encryptOrDecrypt()
        //- console.log(`keys.secret1 = ${this.keys.secret1.base64url}, keys.secret2 = ${this.keys.secret2.base64url}`)
        const sign1 = hs256(this.payload1, this.keys.secret1)
        //- console.log(`     sign1 = ${sign1.base64url}\nthis.sign1 = ${this.sign1.base64url}`)
        if (!sign1.isEqual(this.sign1)) return false
        const sign2 = hs256(this.payload2, this.keys.secret2)
        this.pack.set(bak) // restore this.pack
        //- console.log(`     sign2 = ${sign2.base64url}\nthis.sign2 = ${this.sign2.base64url}`)
        return sign2.isEqual(this.sign2)
      }

      fixSignature (skipDecrypt = false) {
        const { hs256 } = AmiiboNtag215
        const bak = new Packet(this.pack)
        this.keys = this.generateKeys()
        if (!skipDecrypt) this.encryptOrDecrypt()
        this.sign1.set(hs256(this.payload1, this.keys.secret1))
        this.sign2.set(hs256(this.payload2, this.keys.secret2))
        if (!skipDecrypt) this.encryptOrDecrypt()
      }

      setUid (uid7b) {
        if (!Packet.isLen(uid7b, 7)) throw new TypeError('uid7b should be Packet')
        if (uid7b[0] !== 0x04) throw new TypeError('uid7b[0] should be NXP (0x04)')

        this.keys = this.generateKeys() // old keys
        this.encryptOrDecrypt() // decrypt

        this.uid.set(uid7b.subarray(0, 3), 0)
        this.uid[3] = uid7b.subarray(0, 3).xor ^ 0x88 // bcc0 = CT (0x88) ^ uid0 ^ uid1 ^ uid2
        this.uid.set(uid7b.subarray(3, 7), 4)
        this.pack[9] = uid7b.subarray(3, 7).xor // bcc1 = uid3 ^ uid4 ^ uid5 ^ uid6

        this.fixSignature(true) // generateKeys
        this.encryptOrDecrypt() // encrypt
      }

      randomUid () {
        const uid7b = Packet.fromWordArray(CryptoJS.lib.WordArray.random(7))
        uid7b[0] = 0x04
        this.setUid(uid7b)
      }
    }

    const linkDump = Packet.fromBase64('BLM5BtrpTID/SA/g8RD/7qUAAADftJu8ASUfBDYbSkz/ZDJpDZiJM5/FDNiEDcsj4g4W+9QZLFLej5mzOu+rA2fux+6Qz3cr1K3j7s/6Yl6L5tClAQAAAANPCQINEqYPHVHwUQHrI655GO1w1n9AFUCyI93w28c+6Yb7cDxt86+Epx3iXPIh1aFuGqxuqJu3evxnD80lmgfFBDVeCpfnlAAcqGUaFkvm4RctwDAbolOggCGRFP17cKCQ3kiN1pM+gkIWKcBYpJ13Je7c/LGspdJV9F2Uy5qVVw9eqTQAY7JOiMwkWoljb0Au7w6Ook7Gw0hKAH79Obr9XC3JKLqAyxvQ8wMmjYvtkKyp9htsTeyR+MSbz2QIvNJ+zZiaMpbUGIXFwvBSPMqdBiC1gLwOmYQQ8sqTptSDX1ENXeQNJIa3cNyjQBgk7sEFSokImvjCq5WmaMfsz9Z16wpum0KWTEwLJP0VVgTiM+Ly6OIp5Mm1vW+9iaUEPF7toZeLldCvGS9lMg6MDCsWNwFpxfNs4WTbOe095xEQcaWznXJCf5XYtQbK6mQUnTMlXHqusa3cwyjIdVCFf18S8t9+FN7kKtJn7aNXXPQgZn9cpuRNB1V58wxw2um9XshME3dab7QONAnI5SXEgtkaXTjMMPlfpbhY5kUlazp9sZIQ7nepBhnji6Q8YIQ3xAEAD70AAAAEXwAAAAAAAAAAAAAA')

    window.a = AmiiboNtag215.fromBin(linkDump)

    Map.prototype.filter = function (predicate) {
      if (!_.isFunction(predicate)) return []
      return _.filter([...this.entries()], ([k, v]) => predicate(v, k, this))
    }
    class AmiiboDatabase {
      constructor () {
        this.ready = new Promise((resolve, reject) => { [this.readyResolve, this.readyReject] = [resolve, reject] })
        this.fetchDb()
      }

      async fetchDb () {
        try {
          const [jsonAmiibos1, jsonAmiibos2, jsonGames] = _.map(await Promise.all([
            axios.get('https://raw.githubusercontent.com/N3evin/AmiiboAPI/master/database/amiibo.json'),
            axios.get('https://raw.githubusercontent.com/hax0kartik/wumiibo/master/jsons/amiibos.json'),
            axios.get('https://raw.githubusercontent.com/N3evin/AmiiboAPI/master/database/games_info.json'),
          ]), 'data')
          console.log({ jsonAmiibos1, jsonAmiibos2, jsonGames })

          // parse jsonAmiibos1
          const amiiboSeries = new Map(_.map(jsonAmiibos1.amiibo_series, (v, k) => [
            _.parseInt(k.slice(2), 16),
            { id: _.parseInt(k.slice(2), 16), name: v },
          ]))
          const characters = new Map(_.map(jsonAmiibos1.characters, (v, k) => [
            _.parseInt(k.slice(2), 16),
            { id: _.parseInt(k.slice(2), 16), name: v },
          ]))
          const gameSeries = new Map(_.map(jsonAmiibos1.game_series, (v, k) => [
            _.parseInt(k.slice(2), 16),
            { id: _.parseInt(k.slice(2), 16), name: v },
          ]))
          const amiiboTypes = new Map(_.flatMap(jsonAmiibos1.types, (v, k) => [
            [_.parseInt(k.slice(2), 16), v],
            [v, _.parseInt(k.slice(2), 16)],
          ]))
          const amiibos = new Map(_.map(jsonAmiibos1.amiibos, (v, k) => [ k.slice(2), { ...v } ]))

          // parse and merge jsonAmiibos2
          for (const [k1, v1] of _.toPairs(jsonAmiibos2)) {
            for (const v2 of v1) {
              const amiiboId = v2[1].slice(2)
              const amiibo = amiibos.get(amiiboId) ?? { id: amiiboId, name: v2[0] }
              if (amiibo.name !== v2[0]) amiibo.name2 = v2[0]
              amiibos.set(amiiboId, amiibo)
            }
          }

          // amiibo mappings
          const tmpAid = new Packet(8)
          for (const [k1, v1] of amiibos.entries()) {
            tmpAid.setBigUint64(0, BigInt(`0x${k1}`), false)
            _.assign(v1, {
              // ID of the series
              amiiboSeries: amiiboSeries.get(tmpAid[6]),

              // the first element is the collection ID, the second the character in this collection, the third the variant
              character: characters.get(tmpAid.getUint16(0, false)),
              gameSeries: gameSeries.get(tmpAid.getUint16(0, false) >>> 4),
              id: tmpAid.hex,
              image: `https://raw.githubusercontent.com/N3evin/AmiiboAPI/master/images/icon_${tmpAid.subarray(0, 4).hex}-${tmpAid.subarray(4, 8).hex}.png`,
              modelId: tmpAid.getUint16(4, false),

              // Type of amiibo 0 = figure, 1 = card, 2 = plush
              type: amiiboTypes.get(tmpAid[3]),
              unknownId: tmpAid[7],

              // ID shared by all exact same amiibo. Some amiibo are only distinguished by this one like regular SMB Series Mario and the gold one
              variantId: tmpAid.getUint24(0, false),
            })
          }

          // parse games
          const games = new Map()
          for (const [k1, v1] of _.toPairs(jsonGames.amiibos)) {
            const amiibo = amiibos.get(k1.slice(2))
            for (const tmpType of ['games3DS', 'gamesSwitch', 'gamesWiiU']) {
              for (const tmpGame of v1[tmpType]) {
                const gameUniq = `${tmpType.slice(5)}-${tmpGame.gameName}`
                const game = games.get(gameUniq) ?? { name: tmpGame.gameName, platform: tmpType.slice(5) }
                // merge games data
                game.amiiboUsage = _.uniqBy([...(game.amiiboUsage ?? []), ...tmpGame.amiiboUsage], usage => `${usage.Usage}${+usage.write}`)
                game.ids = _.uniq([...(game.ids ?? []), ...tmpGame.gameID])
                games.set(gameUniq, game)
                for (const gid of game.ids) games.set(gid, game)
                if (amiibo) {
                  amiibo[tmpType] = _.uniqBy([...(amiibo[tmpType] ?? []), game], 'name')
                  game.amiibos = _.uniqBy([...(game.amiibos ?? []), amiibo], 'id')
                }
              }
            }
          }

          _.assign(this, { amiibos, amiiboSeries, amiiboTypes, characters, gameSeries, games })
          this.readyResolve()
        } catch (err) {
          console.error(err)
          this.readyReject(err)
        }
      }
    }
    window.amiiboDb = new AmiiboDatabase()

    window.vm = new Vue({
      el: '#app',
      data: {
        h: {},
      },
      async mounted () {
        // 自動儲存功能
        try {
          const saved = JSON5.parse(localStorage.getItem(location.pathname))
          if (saved) this.$set(this, 'h', { ...this.h, ...saved })
        } catch (err) {}
        this.$watch('h', () => {
          localStorage.setItem(location.pathname, JSON5.stringify(this.h))
        }, { deep: true })
      },
    })
